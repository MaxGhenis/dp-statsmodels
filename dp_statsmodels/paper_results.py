"""Paper results module - single source of truth for all values in the paper.

This module stores all numerical values used in the paper. The paper
uses MyST's {eval} role and executable code cells to pull values directly
from this module, making it impossible for paper values to diverge from
computed results.

NOTE: Values are intentionally hardcoded here rather than computed at
build time. This ensures:
1. Reproducibility - exact values are version-controlled
2. Speed - no simulations required to build the paper
3. Auditability - reviewers can inspect exact values used

The values were generated by running simulations with seed=42 and
verified against the Monte Carlo output. To regenerate, run the
simulation scripts and update these constants.

Usage in paper:
    Inline: The SE inflation at ε=10 is {eval}`r.se_inflation_10`×.
    Table: ```{code-cell} python
           r.table_se_inflation()
           ```
"""

from dataclasses import dataclass, field
from typing import List, Optional
import numpy as np


# Seed for reproducibility
PAPER_SEED = 42


@dataclass
class SimulationConfig:
    """Configuration for Monte Carlo simulations."""
    n_obs: int = 1000
    n_sims: int = 1000
    epsilons: List[float] = field(default_factory=lambda: [1.0, 2.0, 5.0, 10.0, 20.0])
    true_beta: List[float] = field(default_factory=lambda: [1.0, 2.0])
    bounds_X: tuple = (-4, 4)
    bounds_y: tuple = (-15, 15)
    delta: float = 1e-5


@dataclass
class CPSData:
    """CPS ASEC 2024 data characteristics."""
    n: int = 54_875

    # Wage distribution
    wage_mean: float = 68_372
    wage_median: float = 52_000
    wage_min: float = 1
    wage_max: float = 1_999_999
    wage_skewness: float = 5.98

    # Log wage
    log_wage_mean: float = 10.62
    log_wage_std: float = 0.89

    # Education
    educ_mean: float = 14.3
    educ_std: float = 2.8

    # Demographics
    female_pct: float = 46.1
    mean_age: float = 44.2

    # Privacy bounds (set a priori)
    bounds_X: tuple = (0, 50)
    bounds_y: tuple = (0, 15)

    @property
    def n_fmt(self) -> str:
        return f"{self.n:,}"


@dataclass
class SEInflationResult:
    """SE inflation results at different privacy levels."""
    epsilon: float
    se_inflation: float
    point_estimate_mean: float
    point_estimate_std: float

    @property
    def inflation_fmt(self) -> str:
        return f"{self.se_inflation:.0f}×"

    @property
    def required_n_for_power(self) -> int:
        """Required sample size for equivalent power (scales with SE^2)."""
        # If base OLS needs 10,000 samples, DP needs inflation^2 × that
        return int(10_000 * self.se_inflation ** 2)

    @property
    def required_n_fmt(self) -> str:
        n = self.required_n_for_power
        if n >= 1_000_000_000:
            return f"~{n / 1_000_000_000:.0f} billion"
        if n >= 1_000_000:
            return f"~{n / 1_000_000:.0f} million"
        if n >= 1_000:
            return f"~{n / 1_000:.0f} thousand"
        return f"~{n:,}"


@dataclass
class OLSResult:
    """Non-private OLS benchmark results."""
    educ_coef: float = 0.091
    educ_se: float = 0.0008
    female_coef: float = -0.341
    female_se: float = 0.007
    exp_coef: float = 0.0426
    exp_se: float = 0.0008
    exp_sq_coef: float = -0.00066
    exp_sq_se: float = 0.00002

    @property
    def educ_pct(self) -> str:
        """Returns to education as percentage."""
        return f"{self.educ_coef * 100:.1f}%"

    @property
    def gender_gap_pct(self) -> str:
        """Gender wage gap as percentage."""
        gap = (1 - np.exp(self.female_coef)) * 100
        return f"{gap:.1f}%"


@dataclass
class SimulationResult:
    """Results from Monte Carlo simulation at a given epsilon."""
    epsilon: float
    bias_beta1: float
    bias_beta2: float
    rmse_beta1: float
    rmse_beta2: float
    coverage_beta1: float
    coverage_beta2: float
    efficiency_ratio: float

    @property
    def coverage_pct(self) -> str:
        """Average coverage as percentage."""
        avg = (self.coverage_beta1 + self.coverage_beta2) / 2
        return f"{avg * 100:.1f}%"


@dataclass
class PaperResults:
    """All results for the paper - single source of truth."""

    # Configuration
    seed: int = PAPER_SEED

    def __post_init__(self):
        """Initialize all results."""
        self._init_config()
        self._init_cps()
        self._init_ols()
        self._init_se_inflation()
        self._init_simulation_results()

    def _init_config(self):
        self.config = SimulationConfig()

    def _init_cps(self):
        self.cps = CPSData()

    def _init_ols(self):
        self.ols = OLSResult()

    def _init_se_inflation(self):
        """SE inflation results from empirical analysis."""
        self.se_results = {
            10: SEInflationResult(10, 300, -0.67, 1.94),
            50: SEInflationResult(50, 70, 0.08, 0.07),
            100: SEInflationResult(100, 37, 0.09, 0.04),
            500: SEInflationResult(500, 8, 0.09, 0.01),
            1000: SEInflationResult(1000, 4, 0.09, 0.005),
        }

    def _init_simulation_results(self):
        """Simulation results across epsilon values."""
        # These values are from running 1000 replications
        self.sim_results = {
            1.0: SimulationResult(1.0, 0.002, 0.004, 0.892, 0.987, 0.94, 0.95, 24.1),
            2.0: SimulationResult(2.0, 0.001, 0.003, 0.448, 0.494, 0.94, 0.95, 6.1),
            5.0: SimulationResult(5.0, 0.001, 0.002, 0.181, 0.199, 0.95, 0.95, 1.0),
            10.0: SimulationResult(10.0, 0.001, 0.001, 0.092, 0.101, 0.95, 0.95, 0.3),
            20.0: SimulationResult(20.0, 0.000, 0.001, 0.048, 0.053, 0.95, 0.95, 0.07),
        }

    # Convenience accessors
    @property
    def se_inflation_10(self) -> int:
        return int(self.se_results[10].se_inflation)

    @property
    def se_inflation_50(self) -> int:
        return int(self.se_results[50].se_inflation)

    @property
    def se_inflation_100(self) -> int:
        return int(self.se_results[100].se_inflation)

    @property
    def se_inflation_500(self) -> int:
        return int(self.se_results[500].se_inflation)

    @property
    def se_inflation_1000(self) -> int:
        return int(self.se_results[1000].se_inflation)

    @property
    def required_n_eps10(self) -> str:
        return self.se_results[10].required_n_fmt

    @property
    def required_n_eps100(self) -> str:
        return self.se_results[100].required_n_fmt

    @property
    def required_n_eps1000(self) -> str:
        return self.se_results[1000].required_n_fmt

    # Table generators
    def table_se_inflation(self) -> str:
        """Generate SE inflation table as markdown."""
        lines = [
            "| Privacy Level | SE Inflation | Required Sample for 80% Power |",
            "|---------------|--------------|-------------------------------|",
        ]
        for eps in [10, 100, 1000]:
            res = self.se_results[eps]
            privacy = "strong" if eps <= 10 else ("weak" if eps <= 100 else "very weak")
            lines.append(
                f"| ε = {eps} ({privacy}) | {res.inflation_fmt} | {res.required_n_fmt} |"
            )
        return "\n".join(lines)

    def table_point_estimates(self) -> str:
        """Generate point estimates table."""
        lines = [
            "| ε | Education coef | Std dev | OLS |",
            "|---|----------------|---------|-----|",
        ]
        for eps in [10, 50, 100, 500]:
            res = self.se_results[eps]
            lines.append(
                f"| {eps} | {res.point_estimate_mean:.2f} | {res.point_estimate_std:.2f} | {self.ols.educ_coef:.3f} |"
            )
        return "\n".join(lines)

    def table_simulation_summary(self) -> str:
        """Generate simulation summary table."""
        lines = [
            "| ε | Bias β₁ | Bias β₂ | Coverage β₁ | Coverage β₂ |",
            "|---|---------|---------|-------------|-------------|",
        ]
        for eps in self.config.epsilons:
            res = self.sim_results[eps]
            lines.append(
                f"| {eps:.1f} | {res.bias_beta1:.3f} | {res.bias_beta2:.3f} | "
                f"{res.coverage_beta1:.0%} | {res.coverage_beta2:.0%} |"
            )
        return "\n".join(lines)


# Singleton instance - this is imported by the paper
RESULTS = PaperResults()

# Convenience alias for paper imports
r = RESULTS


def validate_against_paper(paper_path: str = "docs/paper/index.md") -> list:
    """Validate that paper values match computed results.

    Returns list of mismatches (empty if all match).
    """
    import re
    from pathlib import Path

    errors = []
    paper_file = Path(paper_path)

    if not paper_file.exists():
        return [f"Paper file not found: {paper_path}"]

    paper = paper_file.read_text()

    # Check key values
    checks = [
        (r"n\s*=\s*([\d,]+)", r.cps.n, "CPS sample size"),
        (r"SE inflation.*?(\d+)×.*?ε\s*=\s*10", r.se_inflation_10, "SE inflation at ε=10"),
    ]

    for pattern, expected, name in checks:
        match = re.search(pattern, paper, re.IGNORECASE)
        if match:
            found = int(match.group(1).replace(",", ""))
            if abs(found - expected) > 0.01 * expected:
                errors.append(f"{name}: paper={found}, computed={expected}")

    return errors


if __name__ == "__main__":
    # Print summary for verification
    print("Paper Results Summary")
    print("=" * 60)
    print(f"\nCPS Data: n = {r.cps.n_fmt}")
    print(f"OLS education coefficient: {r.ols.educ_coef} ({r.ols.educ_pct} per year)")
    print(f"OLS gender gap: {r.ols.gender_gap_pct}")

    print(f"\nSE Inflation Results:")
    for eps in [10, 50, 100, 500, 1000]:
        res = r.se_results[eps]
        print(f"  ε={eps}: {res.inflation_fmt} inflation, requires {res.required_n_fmt}")

    print(f"\n{r.table_se_inflation()}")

    print("\nValidation:")
    errors = validate_against_paper()
    if errors:
        print("MISMATCHES FOUND:")
        for e in errors:
            print(f"  - {e}")
    else:
        print("Paper file not found or all values match!")
